---
published: true
---




<img src="http://www.andylomas.com/images/aggregation_004.jpg" width="200" height="200" />

Diffusion limited aggregation is a technique that attempts to simulate certain forms of growth. It is interesting in that it is both very simple and has broad applications to many diverse phenomena. It has been used to model coral, dendritic crystals, lightning, and snowflakes.

The premise is that you have particles moving randomly. This is called Brownian motion, which has an interesting history in its own right. When a particle hits a static structure, it sticks to it. In the most basic implementation, you start with a single fixed particle and add new particles in the manner described one at a time. The process naturally forms branches structures as the extremities of the growth act to block particles from hitting the interior parts of the static structure.


{% include video id="83297099" provider="vimeo" %}

**Basic Implementation**


There are two approaches to a basic DLA simulation. One works on a fixed grid and the other is grid-free and uses particles. This difference is reflected in many simulation techniques. Grids provide a rigid structure that simplifies the model. In this case a particle can only move along the grid to one of its four neighbours. Working without a grid provides more freedom, but generally creates additional complexity, which can mean it is harder to program or requires more computation.

Here's a grid example.
```
int[][] grid;
//the pixels taken up by one grid square
int grid_size = 2;
void setup() {
  size(600,600);
  background(255);
  fill(0);
  //initialize grid
  grid = new int[width/grid_size][height/grid_size];
  for(int i=0;i<grid.length;++i) {
    for(int j=0;j<grid[0].length;++j) {
      grid[i][j] = 0;
} 
}
  grid[grid.length/2][grid[0].length/2] = 1;
  drawGridSquare(grid.length/2,grid[0].length/2);
}
void draw() {
  addPoint();
}
void drawGridSquare(int x, int y) {
  rect(x*grid_size,y*grid_size,grid_size,grid_size);
}
void addPoint() {
  //initialize random boundary point
  int x,y;
  if(random(1) < .5) {
    x = int(random(grid.length));
    y = int(random(2))*(grid[0].length-1);
  } else {
    x = int(random(2))*(grid.length-1);
    y = int(random(grid[0].length));
  }
  while(true) {
//check neighbors
 if(checkNeighbors(x,y) > 0) break;
//move in a random direction
 float rand = random(1.0);
 //wrap around the grid
 if(rand < .25) {
	x = (x+1)%grid.length;
 } else if(rand < .5) {
	x = (x+grid.length-1)%grid.length;
 } else if(rand < .75) {
	y = (y+1)%grid[0].length;
 } else {
	y = (y+grid[0].length-1)%grid[0].length;
 } 
 
 }
 grid[x][y] = 1;
 drawGridSquare(x,y);
 }

 int checkNeighbors(int x, int y) {
 int neighbors = 0;
 if(x > 0) neighbors += grid[x-1][y];
 if(x < grid.length-1) neighbors += grid[x+1][y];
 if(y > 0) neighbors += grid[x][y-1];
 if(y < grid[0].length-1) neighbors += grid[x][y+1];
 return neighbors;
 }


  
  ```
Note that you could run the simulation on any grid, though it would most likely require a slightly more complex data structure. You could even run it on arbitrary, irregular networks such as one formed from a voronoi diagram.

**Optimization**

Generally, complex simulations will take a lot of computation, and depending on what you want to do with them speed can be an important factor. Therefore, optimising your algorithm is often a necessary step. It is not usually necessary to talk about low level optimization, such as reducing function calls or using fast bit level operations, but higher level algorithmic optimisation are important to understand.

For instance, if you try to run the above code grid-free , essentially nothing will happen. This is because odds are as a particle moves randomly, it will move away from the existing aggregation and never return. So we want to make sure that the particle never moves too far away from the aggregation. This is accomplished by defining a circle around the aggregation that the particle must lay in. We can either have the particle wrap around when it hits the edge or have it “bounce off”. The code below  shows the particle wrapping around. Here we have defined a vector called dla_center  for the center of the aggregation, and bound_radius which equals the radius of the circle that defines the maximum distance allowed from the center. It is necessary to keep track of the center of the aggregation and a radius which contains the aggregation as it grows. Please note that there are number of other approaches to this problem including having a boundary box, bounding off the boundary, or simply restarting the circle in a random starting location. The method shown is not necessarily optimal.

We can also increase the speed o f the intersection part of the code. Notice that each time we try to find an intersection, we go through every circle in the aggregation. We call the time complexity of this function O(n), which means the number of operations growl linearly with number of circles. this can be reduced using a space partitioning algorithm, which mean instead of checking every circle, we only check those that we know are nearby. this type of problem will come up in many different domains, and we will certainly come back to it in the future. There are many techniques called binning. We divide space into a grid of a regular size such that if a circle is in one grid square, it can only intersect with circles in a neighbouring grid square. Because the number of possible neighbouring circles is fixed, finding an intersection becomes a constant time function or O(1).


**Interactions and Extensions**

Once you have a system, you have to figure out how you want to use it. There are almost infinite directions you can take. This is the aspect in which you most directly act as a “designer”. So what follows are merely some options of ways to interact with or develop the DLA system.

We can identify some specific areas in the system we can explore to create variation. The most direct and superficial is how we visualise the aggregation. Often DLA patterns are drawn with the color of a particle corresponding to age. This gives a visual sense of how the structure grows. Another simple change is drawing the pattern as lines instead of circles. This requires keeping track of the structure of which particles are intersection. Other simple change include varying the size of particles or extending the growth to more dimensions.

A property we can add to DLA is called stickiness. Instead of always sticking when a particle intersects, particles stick with some probability. By having a low probability, particles are able to slip past some of the exterior branching creating a denser patter. 

We can also change the environment in which the particle grow. The particles can stick to any initial starting surface. We can also confine the growth into a certain space.
 Finally, the most rich area of variation is changing the way particles move. A simple directional force can be adding by making the particle tend in a certain direction as shown below.

[Code]

Going further, the particles can move in a force field. In the example presented in toxiclibs, a force field is created along a guid curve, sculpting the growth along a specified path. A force field could be created that responds to loud or video, so that the dynamics of the growth change through time. More advanced work studies that is called delectric breakdown modeling, which attempts to simulate when an insulator breaks down and a spark jumps. In practice this is very similar to DLA except replacing the stochastic brownian motion with a solving for the electric field, which is PDE formulation of the diffusion process. In essence, you are solving for the probability that a particle will hit any part of aggregation. In addition, you can manipulate the electric field by other means to effect or sculpt the growth. Some go the links on this page show work in this domain.



[Test formulas]
![equation](http://latex.codecogs.com/gif.latex?Concentration%3D%5Cfrac%7BTotalTemplate%7D%7BTotalVolume%7D)




----
![equation](https://latex.codecogs.com/gif.latex?a=\beta&space;&plus;&space;\delta)
